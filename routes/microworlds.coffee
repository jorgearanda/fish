"use strict"
async = require("async")
Chance = require("chance")
logger = require("winston")
Microworld = require("../models/microworld-model").Microworld

# GET /microworlds
exports.list = (req, res) ->
  query = "experimenter._id": req.session.userId
  query.status = req.query.status  if req.query.status
  Microworld.find(query).exec findCb = (err, microworlds) ->
    if err
      logger.error "Error on GET /microworlds", err
      return res.send(500)
    res.status(200).send microworlds

  return


# GET /microworlds/:id
exports.show = (req, res) ->
  Microworld.findOne
    _id: req.params.id
  , foundCb = (err, mw) ->
    if err
      logger.error "Error on GET /microworlds/" + req.params.id, err
      return res.send(500)
    res.status(200).send mw

  return


# POST /microworlds
exports.create = (req, res) ->
  
  # For now at least, we assume validation client-side
  st =
    name: req.body.name
    experimenter:
      _id: req.session.userId
      username: req.session.username

    desc: req.body.desc
    status: "test"
    dateCreated: new Date()
    dateActive: null
    dateArchived: null
    numCompleted: 0
    numAborted: 0
    params: req.body

  
  # Don't repeat name and description
  delete st.params.name

  delete st.params.desc

  
  # We need an autogenerated code
  chance = new Chance()
  foundNewCode = false
  tries = 0
  async.waterfall [
    generateCode = (next) ->
      async.doUntil (newCode = (cb) ->
        st.code = chance.string(
          length: 6
          pool: "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"
        )
        tries += 1
        Microworld.findOne
          code: st.code
        , onFound = (err, found) ->
          return cb(err)  if err
          return cb(message: "Error generating microworld code: " + "too many tries")  if tries > 10
          foundNewCode = true  unless found
          cb()

        return
      ), (checkIfFound = ->
        foundNewCode
      ), (err) ->
        if err
          return next(
            status: 500
            message: err.message
          )
        next()

    createMicroworld = (next) ->
      st.name = st.name + " clone " + st.code  if st.params.clone
      Microworld.create st, onCreate = (err, stRes) ->
        if err
          return next(
            status: 500
            message: err.message
          )
        next null, stRes

  ], resolve = (err, stRes) ->
    if err
      logger.error "Error on POST /microworlds: ", err  if err.status is 500
      return res.status(err.status).send(err.message)
    res.status(200).send stRes

  return


# PUT /microworlds/:id
exports.update = (req, res) ->
  
  # For now at least, we assume validation client-side
  mw =
    name: req.body.name
    desc: req.body.desc
    params: req.body

  if req.body.changeTo and req.body.changeTo is "active"
    mw.status = "active"
    mw.dateActive = new Date()
    mw.dateArchived = null
  if req.body.changeTo and req.body.changeTo is "archived"
    mw.status = "archived"
    mw.dateArchived = new Date()
  
  # Don't repeat name, description, or changeTo
  delete mw.params.name

  delete mw.params.desc

  delete mw.params.changeTo

  Microworld.update
    _id: req.params.id
  , mw, onUpdate = (err) ->
    if err
      logger.error "Error on PUT /microworlds/" + req.params.id, err
      return res.send(500)
    res.send 204

  return


# DELETE /microworlds/:id
exports.delete = (req, res) ->
  Microworld.remove
    _id: req.params.id
  , onDelete = (err) ->
    if err
      logger.error "Error on DELETE /microworlds/" + req.params.id, err
      return res.send(500)
    res.send 204

  return
