'use strict';

var async = require('async');
var Chance = require('chance');
var logger = require('winston');

var Microworld = require('../models/microworld-model').Microworld;

// GET /microworlds
exports.list = function (req, res) {
    var query = { 'experimenter._id': req.session.userId };
    if (req.query.status) query.status = req.query.status;

    Microworld.find().exec(function findCb(err, microworlds) {
        if (err) {
            logger.error('Error on GET /microworlds', err);
            return res.send(500);
        }

        return res.status(200).send(microworlds);
    });
};


// GET /microworlds/:id
exports.show = function (req, res) {
    Microworld.findOne({
        _id: req.params.id
    }, function foundCb(err, mw) {
        if (err) {
            logger.error('Error on GET /microworlds/' + req.params.id, err);
            return res.send(500);
        }

        return res.status(200).send(mw);
    });
};


// GET /microworlds/:id/fish
exports.fish = function (req, res) {
    res.render('fish.html');
};


// POST /microworlds
exports.create = function (req, res) {
    // For now at least, we assume validation client-side
    var st = {
        name: req.body.name,
        experimenter: {
            _id: req.session.userId,
            username: req.session.username
        },
        desc: req.body.desc,
        status: 'test',
        dateCreated: new Date(),
        dateActive: null,
        dateArchived: null,
        numCompleted: 0,
        numAborted: 0,
        params: req.body
    };

    // Don't repeat name and description
    delete st.params.name;
    delete st.params.desc;

    // We need an autogenerated code
    var chance = new Chance();
    var foundNewCode = false;
    var tries = 0;

    async.waterfall([
        function generateCode(next) {
            async.doUntil(
                function newCode(cb) {
                    st.code = chance.string({
                        length: 6,
                        pool: 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'
                    });
                    tries += 1;

                    Microworld.findOne(
                        {'code': st.code},
                        function onFound(err, found) {
                            if (err) return cb(err);
                            if (tries > 10) {
                                return cb({
                                    message: 'Error generating microworld code: ' +
                                        'too many tries'});
                            }
                            if (!found) foundNewCode = true;
                            return cb();
                        });
                },
                function checkIfFound() {
                    return foundNewCode;
                },
                function (err) {
                    if (err) return next({status: 500, message: err.message});
                    return next();
                }
            );
        }, function createMicroworld(next) {
            if (st.params.clone) {
                st.name = st.name + ' clone ' + st.code;
            }
            
            Microworld.create(st, function onCreate(err, stRes) {
                if (err) return next({status: 500, message: err.message});

                return next(null, stRes);
            });
        }
    ], function resolve(err, stRes) {
        if (err) {
            if (err.status === 500) {
                logger.error('Error on POST /microworlds: ', err);
            }
            return res.status(err.status).send(err.message);
        }
        return res.status(200).send(stRes);
    });
};

// PUT /microworlds/:id
exports.update = function (req, res) {
    // For now at least, we assume validation client-side
    var mw = {
        name: req.body.name,
        desc: req.body.desc,
        params: req.body
    };

    if (req.body.changeTo && req.body.changeTo === 'active') {
        mw.status = 'active';
        mw.dateActive = new Date();
        mw.dateArchived = null;
    }

    if (req.body.changeTo && req.body.changeTo === 'archived') {
        mw.status = 'archived';
        mw.dateArchived = new Date();
    }

    // Don't repeat name, description, or changeTo
    delete mw.params.name;
    delete mw.params.desc;
    delete mw.params.changeTo;

    Microworld.update({_id: req.params.id}, mw, function onUpdate(err) {
        if (err) {
            logger.error('Error on PUT /microworlds/' + req.params.id, err);
            return res.send(500);
        }

        return res.send(204);
    });
};

// DELETE /microworlds/:id
exports.delete = function (req, res) {
    Microworld.remove({_id: req.params.id}, function onDelete(err) {
        if (err) {
            logger.error('Error on DELETE /microworlds/' + req.params.id, err);
            return res.send(500);
        }

        return res.send(204);
    });
};
